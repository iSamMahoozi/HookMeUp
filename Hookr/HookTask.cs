using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using Microsoft.Build.Framework;
using Microsoft.Build.Tasks;
using Microsoft.Build.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Hookr
{
    public sealed class HookTask : Task
    {
        [Required]
#warning Can we handle Wildcards or are they automatically expanded?
#warning Generated files, if added to the project should be nested under the originals
#warning During testing initial build doesn't work because the injecting task assembly hasn't been created yet so build fails
#warning During testing multiple builds may not work because MSBuild is accessing the previous assembly
#warning The UsingTask MSBuild element refers to the AssemblyFile rather than just the name
#warning Hooks should be excluded from hooking process
        public string Inputs { get; set; }

        [Output]
        public string Outputs { get; set; }

        public override bool Execute()
        {
            // System.Diagnostics.Debugger.Launch();
            var CRLF = Environment.NewLine;
            var compileFiles = Inputs.Split(';');
            foreach (var compileFile in compileFiles)
            {
                try
                {
                    if (compileFile.EndsWith(".g.cs"))
                    {
                        continue;
                    }
                    var originalContent = File.ReadAllText(compileFile);
                    var content = originalContent.Replace("{{VALUE}}", "Hello World!");
                    var lineNumberReplacementToken = "#line {{#LINENUMBER#}}";
                    var header = @"/*
This file was automatically generated by Hook Me Up - No use modifying
GitHub Link
Copyright Notice
*/" + CRLF;
                    header += $"#line 1 \"{compileFile}\"" + CRLF;
                    content = header + content;
                    var injectedCode = CRLF + @"#line hidden
Console.WriteLine(""INJECTED CODE"");" + CRLF +
lineNumberReplacementToken + CRLF;
#warning This actually ignores any whitespace and therefore changes the properties of the line (columnStart & columnEnd) therefore the lines at debugging will look strange
                    var replacementToken = "Console.WriteLine";
                    // content = content.Replace(replacementToken, injectedCode + replacementToken);
                    content = Regex.Replace(content, $"[{CRLF}](.*{replacementToken})", $"{injectedCode}$1");
                    IList<int> lines = new List<int>();
                    using (var reader = new StringReader(content))
                    {
                        var lineNumber = 0;
                        string line;
                        var isHidden = true;
                        while ((line = reader.ReadLine()) != null)
                        {
                            if (line == $"#line 1 \"{compileFile}\"")
                            {
                                isHidden = false;
                            }

                            if (line == "#line hidden")
                            {
                                isHidden = true;
                                continue;
                            }

                            if (line.StartsWith("#line"))
                            {
                                isHidden = false;
                            }
                            else if (!isHidden)
                            {
                                lineNumber++;
                            }

                            if (line.StartsWith(lineNumberReplacementToken))
                            {
                                lines.Add(++lineNumber);
                            }
                        }
                    }

                    while (content.Contains(lineNumberReplacementToken) && lines.Count > 0)
                    {
                        var index = content.IndexOf(lineNumberReplacementToken);
                        var lineNumberDirective = lineNumberReplacementToken.Replace("{{#LINENUMBER#}}", $"{lines[0]} \"{compileFile}\"");
                        lines.RemoveAt(0);
                        content = content.Substring(0, index) + lineNumberDirective + content.Substring(index + lineNumberReplacementToken.Length);
                    }

                    var generatedFile = Regex.Replace(compileFile, ".cs$", ".g.cs");
                    File.WriteAllText(generatedFile, content);
                }
                catch (Exception ex)
                {
                    Log.LogWarning($"Could not open {compileFile}. {ex}");
                }
            }

            Outputs = "*.g.cs";
            Log.LogMessage(MessageImportance.High, $"Items to compile:{CRLF}{string.Join(CRLF, compileFiles)}");
            return true;
        }
    }
}